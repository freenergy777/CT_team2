# Analysis steps
# 1) Load epithelial project and subset
# 2) QC and filtering
# 3) LSI Dim reduction
# 4) ID Cluster Markers
# 5) Plot Markers
# 6) Define clusters
# 7) Project all samples into normal manifold
# 8) Compute differential tests
# 9) Compute malignancy continuum

```{r}
suppressPackageStartupMessages({
library(dplyr)
library(Seurat)
library(ggplot2)
library(RColorBrewer)
library(ArchR)
library(viridis)
library(DoubletFinder)
library(Rcpp)
library(harmony)
library(future)
library(Matrix)
library(RANN)
library(MAST)
})
```

```{r}
# Define variables
execute_steps <- 1:9

# folder to save the results
analysis_parent_folder <- "/home/hjlee/Becker/GSE201348_RAW/epithelial_results/"

# load seurat object containing all epithelial cells
colon_full <- readRDS("/home/hjlee/Becker/Final_scHTAN_colon_all_epithelial_220213.rds")
colon_full <- UpdateSeuratObject(colon_full)

# load metadata
metadata <- read.table("/home/hjlee/Becker/hubmap_htan_metadata_atac_and_rna_final.csv", header = TRUE, sep = ",", stringsAsFactors=FALSE)

# LSI Params
resolution <- c(0.1,0.2,0.4,0.8) # author selected this PCs
umapNeighbors <- 50
umapMinDist <- 0.45
umapDistMetric <- "cosine"
nTop <- 1600
initial_nPCs <- 1:8
final_nPCs <- c(1:4,6:8)
nPCs <- initial_nPCs

# Create directory
if (!dir.exists(paste0(analysis_parent_folder))){
  dir.create(paste0(analysis_parent_folder))
}
setwd(analysis_parent_folder)

```

```{r}
# Define Functions--as noted above, multiple functions copied from Granja et al 2019
sourceCpp(code='
  #include <Rcpp.h>
  using namespace Rcpp;
  using namespace std;
  // [[Rcpp::export]]
  Rcpp::NumericVector computeSparseRowVariances(IntegerVector j, NumericVector val, NumericVector rm, int n) {
    const int nv = j.size();
    const int nm = rm.size();
    Rcpp::NumericVector rv(nm);
    Rcpp::NumericVector rit(nm);
    int current;
    // Calculate RowVars Initial
    for (int i = 0; i < nv; ++i) {
      current = j(i) - 1;
      rv(current) = rv(current) + (val(i) - rm(current)) * (val(i) - rm(current));
      rit(current) = rit(current) + 1;
    }
    // Calculate Remainder Variance
    for (int i = 0; i < nm; ++i) {
      rv(i) = rv(i) + (n - rit(i))*rm(i)*rm(i);
    }
    rv = rv / (n - 1);
    return(rv);
  }'
)

sparseRowVariances <- function (m){
  #Compute Fast Sparse Row Variances--From Granja et al 2019
  rM <- Matrix::rowMeans(m)
  rV <- computeSparseRowVariances(m@i + 1, m@x, rM, ncol(m))
  return(rV)
}

getVarGenesFilterBlacklist <- function(mat, nTopGenes = 2000, blacklist = NULL){
  # Get the top nTopGenes variable genes present in mat (a gene x sample/cell matrix)
  # If blacklist is present, do not return any genes in the blacklist
  if(!is.null(blacklist)){
    mat <- mat[!rownames(mat) %in% blacklist,]
  }
  # compute row variances and return the most variable genes for either matrix or sparse matrix
  var_genes <- {
    v <- if (is.matrix(mat)) matrixStats::rowVars(mat) 
    else sparseRowVariances(mat)
    rownames(mat)[head(order(v, decreasing = TRUE), nTopGenes)]
  }
  # return results
  var_genes
}

calcLSI <- function(mat, nComponents = 50, binarize = TRUE, nFeatures = NULL){
  #From Granja et al 2019
  set.seed(1)
  
  #TF IDF LSI adapted from flyATAC
  if(binarize){
    message(paste0("Binarizing matrix..."))
    mat@x[mat@x > 0] <- 1
  }
  
  #Calc RowSums and ColSums
  colSm <- Matrix::colSums(mat)
  rowSm <- Matrix::rowSums(mat)
  
  #Calc TF IDF
  message("Computing Term Frequency IDF...")
  freqs <- t(t(mat)/colSm)
  idf   <- as(log(1 + ncol(mat) / rowSm), "sparseVector")
  tfidf <- as(Matrix::Diagonal(x=as.vector(idf)), "sparseMatrix") %*% freqs
  
  #Calc SVD then LSI
  message("Computing SVD using irlba...")
  svd <- irlba::irlba(tfidf, nComponents, nComponents)
  svdDiag <- matrix(0, nrow=nComponents, ncol=nComponents)
  diag(svdDiag) <- svd$d
  matSVD <- t(svdDiag %*% t(svd$v))
  rownames(matSVD) <- colnames(mat)
  colnames(matSVD) <- paste0("PC",seq_len(ncol(matSVD)))
  
  #Return Object
  out <- list(
    matSVD = matSVD, 
    rowSm = rowSm, 
    colSm = colSm, 
    svd = svd, 
    binarize = binarize, 
    nComponents = nComponents,
    seed = 1)
  out
}

#Helper function for summing sparse matrix groups
groupSums <- function (mat, groups = NULL, na.rm = TRUE, sparse = FALSE){
  stopifnot(!is.null(groups))
  stopifnot(length(groups) == ncol(mat))
  gm <- lapply(unique(groups), function(x) {
    if (sparse) {
      Matrix::rowSums(mat[, which(groups == x), drop = F], na.rm = na.rm)
    }
    else {
      rowSums(mat[, which(groups == x), drop = F], na.rm = na.rm)
    }
  }) %>% Reduce("cbind", .)
  colnames(gm) <- unique(groups)
  return(gm)
}

projectLSI <- function(mat, lsi, binarize){   
  #Get Same Features
  mat <- mat[lsi$varFeatures,]
  if(binarize){
    message(paste0("Binarizing matrix..."))
    mat@x[mat@x > 0] <- 1       
  }
  
  #Calc TF IDF
  rowsToZero <- which(lsi$rowSm == 0)
  setToZero <- which((mat@i + 1) %in% rowsToZero)
  if(length(setToZero) > 0){
    mat@x[setToZero] <- 0
  }
  
  message("Computing Term Frequency IDF...")
  freqs <- t(t(mat)/Matrix::colSums(mat))
  idf   <- as(log(1 + length(lsi$colSm) / lsi$rowSm), "sparseVector")
  tfidf <- as(Matrix::Diagonal(x=as.vector(idf)), "sparseMatrix") %*% freqs
  if(length(Matrix::which(is.na(tfidf),arr.ind=TRUE)) > 0){
    tfidf[Matrix::which(is.na(tfidf),arr.ind=TRUE)] <- 0 #weird Inf * 0
  }
  
  #Calc V
  V <- t(tfidf) %*% lsi$svd$u %*% diag(1/lsi$svd$d)
  
  #Calc SVD then LSI
  message("Computing SVD using irlba...")
  svdDiag <- matrix(0, nrow=lsi$nComponents, ncol=lsi$nComponents)
  diag(svdDiag) <- lsi$svd$d
  matSVD <- t(svdDiag %*% t(V))
  rownames(matSVD) <- colnames(mat)
  colnames(matSVD) <- paste0("PC",seq_len(ncol(matSVD)))
  
  return(matSVD)
}

seurat_feature_plot <- function(sample_name, reduction, cell_type, markers){
  # function to make grid layout of seurat feature plots
  p1 <- FeaturePlot(colon, features = markers, reduction = reduction, order = TRUE, combine = FALSE, pt.size = 1, alpha = 0.5)
  if (length(p1)==1){
    width <- 4
    height <- 4
  } else if (length(p1)==2){
    width <- 8
    height <- 4
  } else if (length(p1)<5){
    width <- 8
    height <- 8
  } else if (length(p1)<7){
    width <- 12
    height <- 8
  } else if (length(p1)<10){
    width <- 12
    height <- 12
  } else if (length(p1)<13){
    width <- 16
    height <- 12
  } else if (length(p1)<17){
    width <- 16
    height <- 16
  }
  pdf(paste0("./", reduction, "_feature_plot_", sample_name, "_", cell_type ,".pdf"), width = width, height = height)
  ncol <- if (length(p1) <= 2) length(p1) else ceiling(sqrt(length(p1)))
  combined <- patchwork::wrap_plots(p1, ncol = ncol)
  print(combined) 
  dev.off()
}

vln_plot <- function(features, save_name){
  pdf(save_name, width = 20, onefile=F)
  print(VlnPlot(colon, features = features, group.by = "orig.ident", pt.size = 0, cols = c(rep("tomato3",100)))+
          geom_boxplot(outlier.shape = NA, alpha = 0.6)+theme_ArchR()+theme(legend.position = "none", axis.text.x = element_text(angle = 60, hjust = 1))+
          scale_x_discrete(labels=paste0(data.frame(table(colon@meta.data$orig.ident))$Var1, "\n n = ",  data.frame(table(colon@meta.data$orig.ident))$Freq)))
  dev.off()
}
```

```{r}
# 1) Subset to create normal project

if (1 %in% execute_steps){
  # define normal project containing all normal samples except B001-A-104, which was much lower quality and was not used in reference as a result
  colon <- DietSeurat(subset(colon_full, subset = DiseaseState == "Normal"))
  colon <- DietSeurat(subset(colon, subset = orig.ident != "B004-A-104"))
}
```

```{r}
# 2) QC
if (2 %in% execute_steps){
  # create and set working directory to save qc plots
  if (!dir.exists(paste0(analysis_parent_folder, "all_samples_qc_plots"))){
    dir.create(paste0(analysis_parent_folder, "all_samples_qc_plots"))
  }
  setwd(paste0(analysis_parent_folder, "all_samples_qc_plots"))
  
  # already done, but can add here if you got here a different way
  colon[["percent.mt"]] <- PercentageFeatureSet(colon, pattern = "^MT-")
  
  # Now subset the project and make some nice qc plots for just the epithelial cells--this was already done in the first step
  colon <- subset(colon, subset = nFeature_RNA > 400 & nFeature_RNA < 4000 & percent.mt < 5 & nCount_RNA < 10000)
  vln_plot(c("nFeature_RNA"), paste0("./n_genes_violin_", 'Becker', ".pdf"))
  vln_plot(c("nCount_RNA"), paste0("./n_counts_violin_", 'Becker', ".pdf"))
  vln_plot(c("percent.mt"), paste0("./pMT_violin_", 'Becker', ".pdf"))
  
  setwd(analysis_parent_folder)
}
```

```{r}
# 3) Dim reduction with LSI
if (3 %in% execute_steps){
  #Initialize list for storing iterative LSI output
  lsiOut <- list()
  nPCs <- initial_nPCs
  
  # Get the raw counts
  rawCounts <- GetAssayData(object = colon, layer =  "counts")
  
  # Identify genes (mitochondrial, ribosomal, and HLA) to blacklist for dimensionality reduction
  mt_genes <- grep("^MT-", rownames(colon), value = TRUE)
  rps_genes <- grep("^RPS", rownames(colon), value = TRUE)
  rpl_genes <- grep("^RPL", rownames(colon), value = TRUE)
  hla_genes <- grep("^HLA-", rownames(colon), value = TRUE)
  blacklist <- c(mt_genes, rps_genes, rpl_genes, hla_genes)
  
  # Here we will use the normalized data in the data slot from seurat, which is ln rather than log2 normalized
  log2CP10k <- GetAssayData(object = colon, layer = "data")
  # alternatively could do:
  # log2CP10k <- as(log2(t(t(rawCounts)/Matrix::colSums(rawCounts)) * 10000 + 1), "matrix")
  
  for(i in seq_along(resolution)){
    if(i == 1){
      #Initial LSI uses variances that are across all single cells and will have larger batch relationships
      message("Running initial LSI...")
      varGenes <- getVarGenesFilterBlacklist(log2CP10k, nTopGenes = nTop, blacklist = blacklist)
    } else{
      message(sprintf("Running LSI %s of %s...", i,  length(resolution)))
      # Calculate variable genes using clusters defined in previous LSI iteration
      clusterMat <- edgeR::cpm(groupSums(rawCounts, clusters, sparse = TRUE), log=TRUE, prior.count = 3)
      varGenes <- getVarGenesFilterBlacklist(clusterMat, nTopGenes = nTop, blacklist = blacklist)
    }
    
    # Now run LSI and find clusters
    LSIi <- calcLSI(rawCounts[varGenes,], nComponents = max(nPCs), binarize = FALSE)
    colon[[paste0("LSI_iter",i)]] <- CreateDimReducObject(embeddings = LSIi$matSVD, key = sprintf("LSI%s_", i), assay = "RNA")
    colon <- FindNeighbors(object = colon, reduction = paste0("LSI_iter",i), dims = nPCs, force.recalc = TRUE)
    colon <- FindClusters(object = colon, resolution = resolution[i])
    clusters <- Idents(colon)
    
    # Save LSI iteration
    lsiOut[[paste0("LSI_iter",i)]] <- list(
      lsiMat = LSIi$matSVD, 
      varFeatures = varGenes, 
      clusters = clusters,
      colSm = LSIi$colSm,
      rowSm = LSIi$rowSm,
      svd = LSIi$svd, 
      binarize = LSIi$binarize, 
      nComponents = LSIi$nComponents
    )
  }
  
  # Run uwot to compute the UMAP
  nPCs <- final_nPCs
  uwotUmap <- uwot::umap(
    LSIi$matSVD[,nPCs], 
    n_neighbors = umapNeighbors, 
    min_dist = umapMinDist, 
    metric = umapDistMetric, 
    n_threads = 1, 
    verbose = TRUE, 
    ret_nn = TRUE,
    ret_model = TRUE
  )
  
  # Add to the seurat object and plot
  umap_vals <- uwotUmap[[1]][,1:2]
  #rownames(umap_vals) <- rownames(LSIi$matSVD[,nPCs])
  colnames(umap_vals) <- c("uwotUMAP_1", "uwotUMAP_2")
  colon[["uwot_UMAP"]] <- CreateDimReducObject(embeddings = umap_vals, key = "uwotUMAP_", assay = "RNA")
  
  pdf(paste0("./uwot_UMAP_samples_", nTop, "_vargenes_all_", max(nPCs), "PCs.pdf"), width = 8)
  print(DimPlot(colon, reduction = "uwot_UMAP", group.by = "orig.ident", cols = paletteDiscrete(values = unique(colon@meta.data$orig.ident), set = "stallion", reverse = FALSE)))#, cols = (ArchRPalettes$stallion))
  dev.off()
  
  # Recluster with final nPCs
  colon <- FindNeighbors(object = colon, reduction = paste0("LSI_iter",i), dims = nPCs, force.recalc = TRUE)
  colon <- FindClusters(object = colon, resolution = 0.5) # resolution determination
  
  pdf(paste0("./UMAPclustering" , ".pdf"))
  print(DimPlot(colon, reduction = "uwot_UMAP", cols = paletteDiscrete(values = unique(colon@meta.data$seurat_clusters), set = "stallion", reverse = FALSE)))
  dev.off()
}

table(Idents(colon))
umap_coords <- colon@reductions[["uwot_UMAP"]]@cell.embeddings
umap_flipped <- umap_coords
umap_flipped[,2] <- -umap_coords[,2]   # upside-down plot

#  Save as new reduction
colon[["umap_flipped"]] <- CreateDimReducObject(
  embeddings = umap_flipped,
  key = "FLIP_",
  assay = "RNA"
)
DimPlot(colon, reduction = "umap_flipped", label = TRUE) 
DimPlot(colon, reduction = "umap_flipped", group.by = "orig.ident")
```

```{r}
# 4) ID Cluster Markers to help with manual annotation
if (4 %in% execute_steps){
  colon.markers <- FindAllMarkers(colon, only.pos = TRUE, min.pct = 0.2, logfc.threshold = 0.25, max.cells.per.ident = 250)
}
```

```{r}
# 5) Plot Some Markers on the UMAPs to help with annotation
if (5 %in% execute_steps){
  # validation to confirm where marker genes for each cell type are expressed in the umap_filpped embedding
  reductions_to_plot <- c("umap_flipped")
  for (reduction in reductions_to_plot){
    seurat_feature_plot('Becker', reduction, "CyclingTA", c("TICRR","CDC25C"))
    seurat_feature_plot('Becker', reduction, "ImmatureEnterocytes", c("SLC26A2","CA1"))
    seurat_feature_plot('Becker', reduction, "Tuft", c("GNG13","SH2D7","SH2D6","TRPM5","AZGP1","KRT18","BMX","PSTPIP2","LRMP","PTGS1","IL17RB","HCK","PLCG2","ANXA13"))
    seurat_feature_plot('Becker', reduction, "Best4posEnterocytes", c("BEST4", "CA7","OTOP2","OTOP3", "MYOM1","MT1G","MT1H"))
    seurat_feature_plot('Becker', reduction, "General_Epithelial", c("EPCAM", "KRT8","KRT18"))
    seurat_feature_plot('Becker', reduction, "Immature_Goblet", c("KLK1","ITLN1","WFDC2","CLCA1","LRRC26","RETNLB","SPINK4","AGR2"))
    seurat_feature_plot('Becker', reduction, "Goblet", c("MUC2", "TFF1", "FCGBP","FFAR4","SYTL2","LGALS9B","BCAS1"))
    seurat_feature_plot('Becker', reduction, "Stem", c("SMOC2", "RGMB", "LGR5", "ASCL2", "SOX9", "CD34"))
    seurat_feature_plot('Becker', reduction, "Enteroendocrine", c("CRYBA2","SCGN","FEV","CHGA","GCG","SCG5","PCSK1N","PYY","NEUROD1","MS4A8","DDC"))
  }
}
```

```{r}
# 6) Define clusters
if (6 %in% execute_steps){
new.cluster.ids <- c(
  "TA2", #0
  "TA1", #1
  "Immature Goblet", #2
  "Enterocytes", #3
  "Immature Enterocytes", #4
  "Enterocyte Progenitors", #5
  "TA2", #6
  "Goblet", #7
  "Stem", #8
  "Best4+ Enterocytes", #9
  "TA1", #10
  "CyclingTA", #11
  "Enteroendocrine", #12
  "Tuft" #13
)

# Idents setting
Idents(colon) <- "RNA_snn_res.0.5"

# seurat_clusters를 factor → character → mapping
cluster_ids <- as.character(Idents(colon))
new_ids <- new.cluster.ids[match(cluster_ids, 0:13)]

# Mapping
table(cluster_ids, new_ids, useNA = "ifany")

# Add metadata
colon <- AddMetaData(
  colon,
  metadata = new_ids,
  col.name = "CellType"
)

pdf("./UMAP_cell_type_id.pdf", width = 5, height = 6)
print(
  DimPlot(
    colon,
    group.by = "CellType",
    reduction = "umap_flipped",
    cols = paletteDiscrete(values = unique(colon@meta.data$CellType), set = "stallion", reverse = FALSE),
    label = TRUE,
    raster.dpi = c(512, 512),
    repel = TRUE
  ) + theme_ArchR() + 
    labs(x = 'UMAP dimension 1', y ='UMAP dimension 2') +ggtitle("Cell Type Annotation at Normal sample UMAP")
)
dev.off()

cat("PDF saved: ./UMAP_cell_type_id.pdf\n")
}
```

```{r}
# 7) Project all samples into normal manifold
if (7 %in% execute_steps){
  # Subset data for a sample
  cell_type_df <- data.frame()
  for (sampleName in unique(colon_full@meta.data$orig.ident)){
    # Subset seurat project to get sample only and get the normalized data
    temp <- subset(colon_full, subset = orig.ident == sampleName)
    rawCounts <- GetAssayData(object = temp, slot = "counts")
    
    # project in the previously defined lsi dimensionality reduction and add to temp seurat project--assumes lsiOut is still around, save it and load it if its not
    lsiProjectionMat <- projectLSI(rawCounts,lsiOut[[paste0("LSI_iter",length(resolution))]], binarize = FALSE)
    temp[["LSI_project"]] <- CreateDimReducObject(embeddings = as.matrix(lsiProjectionMat), key = sprintf("LSI_project"), assay = "RNA")
    
    # project into umap and add to temp seurat project
    umapProjection <- uwot::umap_transform(as.matrix(Embeddings(temp, reduction = "LSI_project"))[,nPCs], uwotUmap, verbose = TRUE)
    proDF <- data.frame(X1 = umapProjection[,1], X2 = umapProjection[,2])
    rownames(proDF) <- rownames(Embeddings(temp, reduction = "LSI_project"))
    temp[["uwot_UMAP_projection"]] <- CreateDimReducObject(embeddings = as.matrix(proDF), key = "uwot_UMAP_projection", assay = "RNA")
    
    # now plot the projection and the reference
    refDF <- data.frame(X1 = uwotUmap$embedding[,1], X2 = uwotUmap$embedding[,2], Type = "Reference")
    proDF <- data.frame(X1 = umapProjection[,1], X2 = umapProjection[,2], Type = "Sample")
    projectionDF <- rbind(refDF, proDF)
    p <- ggplot(projectionDF, aes(X1,X2,color=Type)) + 
      geom_point(size = 0.1, alpha = 1) + 
      xlab("UMAP Dimension 1") + 
      ylab("UMAP Dimension 2") + 
      theme_ArchR(baseSize = 10) + ggtitle("projection") + 
      theme(axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank())+
      scale_color_manual(values=c("Reference"="#D5D5D5","Sample"="#008F95"))
    pdf(paste0("./uwot_projection_", sampleName, "_", nTop, "_vargenes_all_", max(nPCs), "PCs.pdf"), width = 12)
    print(p)
    dev.off()
    
    # Now id cell based on nearest neghbors
    library(FNN)
    input_knn <- 25
    nPCs <- final_nPCs
    svdReference <- as.data.frame(lsiOut[[paste0("LSI_iter",length(resolution))]]$lsiMat)
    svdDisease <- as.data.frame(as.matrix(lsiProjectionMat))
    knnDisease <- get.knnx(
      data = svdReference[,nPCs],
      query = svdDisease[,nPCs],
      k = input_knn)
    
    cellTypes <- c()
    for (j in 1:length(knnDisease$nn.index[,1])){
      types <- colon@meta.data$CellType[knnDisease$nn.index[j,]]
      cellTypes <- c(cellTypes,labels(sort(table(types),decreasing=TRUE)[1]))
    }
    refDF$CellType <- "Reference"
    proDF$CellType <- cellTypes
    projectionDF2 <- rbind(refDF, proDF)
    
    pal <- paletteDiscrete(values = unique(proDF$CellType), set = "stallion", reverse = FALSE)
    pal["Reference"] <- "#D5D5D5"
    p <- ggplot(projectionDF2, aes(X1,X2,color=CellType)) + 
      geom_point(size = 0.2, alpha = 1) +
      xlab("UMAP Dimension 1") + 
      ylab("UMAP Dimension 2") +
      theme_ArchR(baseSize = 10) + ggtitle(sampleName) + 
      theme(axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank())+
      scale_color_manual(values=c("Reference"="#D5D5D5", "Best4+ Enterocytes"="#D51F26", "CyclingTA"="#272E6A", "Enterocyte Progenitors" = "#208A42", "Enterocytes" = "#89288F", 
                                  "Enteroendocrine" = "#F47D2B", "Goblet" = "#FEE500", "Immature Enterocytes" = "#8A9FD1", "Immature Goblet" = "#C06CAB", "Secretory TA" = "#D24B27", "Stem" = "#D8A767", "TA1" = "#90D5E4", "TA2" = "#89C75F", "Tuft" = "#F37B7D"))
    pdf(paste0("./uwot_projection_", sampleName, "_", nTop, "_vargenes_all_", max(nPCs), "PCs.pdf"), width = 6)
    print(p)
    dev.off()
    
    current_cell_types <- DataFrame("Cell" = rownames(svdDisease), "CellType" = cellTypes)
    cell_type_df <- rbind(cell_type_df, current_cell_types)
  }
  write.csv(cell_type_df, "allEpithelialCellTypes.csv")
  colon_full <- AddMetaData(colon_full, cell_type_df$CellType, col.name = "CellType")
  
  # save seurat objects
  saveRDS(colon, "clustered_normal_colon_proj_seurat.rds")
  saveRDS(DietSeurat(colon), "diet_clustered_normal_colon_proj_seurat.rds")
  
  saveRDS(colon_full, "clustered_all_samples_epithelial_colon_proj_seurat.rds")
  saveRDS(DietSeurat(colon_full), "diet_clustered_all_samples_epithelial_colon_proj_seurat.rds")
}
```

```{r}
# 8) Compute differential tests of stem cells relative to normal and unaffected stem cells
if (8 %in% execute_steps) {
  library(Seurat)
  library(dplyr)
  
  # Data loading
  colon_full <- readRDS("diet_clustered_all_samples_epithelial_colon_proj_seurat.rds")
  backgrounds <- c("Unaffected", "NormalColon") 
  
  setup_list <- list()
  
  for (background in backgrounds) {
    cat("\n=== Setting up background:", background, "===\n")
    
    if (background == "NormalColon") {
      sample_col <- "SimplifiedSampleName"
      bg_stem <- "NormalColonStem"
      meta_col <- "CellTypeSimplifiedSample"
      all_samples <- unique(colon_full@meta.data[[sample_col]])
    } else {
      sample_col <- "DifferentialGroup"
      bg_stem <- "UnaffectedStem"
      meta_col <- "CellTypeSimplifiedSample2"
      all_samples <- unique(colon_full@meta.data[[sample_col]])
    }
    
    potential_samples <- paste0(all_samples, "Stem")
    
    # Select Stem sample
    meta_combo <- paste0(colon_full@meta.data[[sample_col]], colon_full@meta.data$CellType)
    existing_groups <- unique(meta_combo[colon_full@meta.data$CellType == "Stem"])
    
    if (background == "NormalColon") {
      samples <- setdiff(intersect(potential_samples, existing_groups), bg_stem)
    } else {
      samples <- intersect(potential_samples, c("NormalColonStem", "UnaffectedStem"))
      samples <- intersect(samples, existing_groups)
    }
    
    if (!meta_col %in% colnames(colon_full@meta.data)) {
      colon_full <- AddMetaData(
        colon_full,
        metadata = paste0(colon_full@meta.data[[sample_col]], colon_full@meta.data$CellType),
        col.name = meta_col
      )
    }
    
    setup_list[[background]] <- list(
      samples = samples,
      background = bg_stem,
      meta_col = meta_col
    )
    
    cat("Valid samples:", paste(samples, collapse=", "), "\n")
  }
  
  # 3. FindMarkers
  colon_full_diff_test <- NULL
  
  for (background in backgrounds) {
    cfg <- setup_list[[background]]
    samples <- cfg$samples
    bg_stem <- cfg$background
    meta_col <- cfg$meta_col
  
    cat("\n--- Running DE for background:", background, "---\n")
    
    Idents(colon_full) <- meta_col
    bg_count <- sum(Idents(colon_full) == bg_stem, na.rm = TRUE)
    if (bg_count < 3) {
      warning("Background ", bg_stem, " has only ", bg_count, " cells. Skipping.")
      next
    }
    
    for (current_sample in samples) {
      cell_count <- sum(Idents(colon_full) == current_sample, na.rm = TRUE)
      if (cell_count < 3) {
        message("Skip: ", current_sample, " (n=", cell_count, " < 3)")
        next
      }
      
      message("DE: ", current_sample, " (n=", cell_count, ") vs ", bg_stem, " (n=", bg_count, ")")
      
      de <- tryCatch({
        FindMarkers(
          colon_full,
          ident.1 = current_sample,
          ident.2 = bg_stem,
          min.pct = 0.1,
          logfc.threshold = 0.25,
          test.use = "MAST",
          max.cells.per.ident = 500,  
          min.cells.group = 3,       
          verbose = FALSE
        )
      }, error = function(e) {
        message("Error in FindMarkers: ", e$message)
        return(NULL)
      })
      
      if (is.null(de) || nrow(de) == 0) {
        message("No DE genes for ", current_sample)
        next
      }
      
      # Merge
      de <- de %>% tibble::rownames_to_column("gene")
      colnames(de)[-1] <- paste0(colnames(de)[-1], "_", current_sample)
      
      if (is.null(colon_full_diff_test)) {
        colon_full_diff_test <- de
      } else {
        colon_full_diff_test <- full_join(colon_full_diff_test, de, by = "gene")
      }
    }
  }
  
  if (!is.null(colon_full_diff_test)) {
    colon_full_diff_test <- colon_full_diff_test %>%
      tibble::column_to_rownames("gene")
    
    # NA를 0으로 (p_val은 NA → 1, logFC는 0)
    numeric_cols <- sapply(colon_full_diff_test, is.numeric)
    colon_full_diff_test[numeric_cols] <- lapply(
      colon_full_diff_test[numeric_cols], 
      function(x) replace(x, is.na(x), 0)
    )
    # p_val은 NA → 1
    pval_cols <- grep("^p_val_", colnames(colon_full_diff_test))
    colon_full_diff_test[pval_cols] <- lapply(
      colon_full_diff_test[pval_cols], 
      function(x) replace(x, is.na(x), 1)
    )
  }
  
  saveRDS(colon_full_diff_test, "colon_full_diff_expression_results.rds")
  write.csv(colon_full_diff_test, "colon_full_diff_expression_results.csv", row.names = TRUE)
  
  cat("All done! Found", ncol(colon_full_diff_test) %/% 5, "comparisons.\n")
}
```

```{r}
# 9) Compute malignancy continuum
if (9 %in% execute_steps){
  # load the differential test relative to normal stem cells
  colon_full_diff_test <- readRDS("./colon_full_diff_expression_results.rds")
  background <- "Normal"
  typeA <- "Stem"
  
  # select just the logfc and p values
  colon_full_diff_test_avg_logFC <- colon_full_diff_test[,grepl("avg_log2FC", colnames(colon_full_diff_test))]
  colon_full_diff_test_avg_logFC <- colon_full_diff_test_avg_logFC/0.69314718056
  colon_full_diff_test_p_val_adj <- colon_full_diff_test[,grepl("p_val_adj", colnames(colon_full_diff_test))]
  colon_full_diff_test_avg_logFC[is.na(colon_full_diff_test_avg_logFC)] <- 0
  colon_full_diff_test_p_val_adj[is.na(colon_full_diff_test_p_val_adj)] <- 1
  
  # select significant genes with the following cutoffs
  colon_full_diff_test_avg_logFC_significant <- colon_full_diff_test_avg_logFC[(rowSums(colon_full_diff_test_avg_logFC>0.5 & colon_full_diff_test_p_val_adj<0.05)>1 | rowSums(colon_full_diff_test_avg_logFC<(-0.5) & colon_full_diff_test_p_val_adj<0.05)>1), ]
  colon_full_diff_test_p_val_adj_significant <- colon_full_diff_test_p_val_adj[(rowSums(colon_full_diff_test_avg_logFC>0.5 & colon_full_diff_test_p_val_adj<0.05)>1 | rowSums(colon_full_diff_test_avg_logFC<(-0.5) & colon_full_diff_test_p_val_adj<0.05)>1), ]
  
  # compute the pcs on the logfold changes
  pcs <- prcomp(colon_full_diff_test_avg_logFC_significant)
  pc_df <- data.frame(pcs$rotation)
  pc_df$sample <- rownames(pc_df)
  pc_df <- pc_df[-1,]
  
  # remove atac column from metadata
  metadata <- read.table("/home/hjlee/Becker/hubmap_htan_metadata_atac_and_rna_final.csv", header = TRUE, sep = ",", stringsAsFactors=FALSE)
  metadata <- metadata[,colnames(metadata)[2:26]]
  colnames(metadata) <- c("Sample", colnames(metadata)[2:25])
  metadata <- metadata[metadata$Sample != "",]
  sample_names <- substr(rownames(pc_df),12,nchar(rownames(pc_df))-(nchar(typeA)))
  metadata <- metadata[metadata$SimplifiedSampleName %in% sample_names,]
  metadata <- metadata[!duplicated(metadata),]
  # remove specific partial duplicates "A002-C-010-R0", "A002-C-121-R0", "A014-C-114"
  metadata <- metadata[!metadata$Sample %in% c("A002-C-010-R0", "A002-C-121-R0", "A014-C-114"),]
  metadata <- metadata[!metadata$DifferentialGroup == 'NormalColon',] 
  rownames(metadata) <- metadata$SimplifiedSampleName
  metadata <- metadata[sample_names,]
  
  # combine the pcs and the metadata
  pc_df <- cbind(pc_df, metadata)
  scalef <- 1
  pc_df$PC1 <- pc_df$PC1*scalef
  
  # plot the first two pcs
  p <- ggplot(pc_df, aes(x=PC2, y=PC1, color=DiseaseState)) +
    geom_point(size=2) + scale_color_manual(values=c("#D51F26", "#89288F", "#208A42")) + theme_ArchR()
  ggsave(plot=p,height=5,width=5, filename=paste0("All_Polyp_", typeA, "_vs_", background, "_", typeA, "_pca_on_diff_genes.pdf"), useDingbats=FALSE)
  
  # fit a spline (0.11 knot selected based on previous plot)
  require(splines)
  fit<-lm(PC1 ~ bs(PC2,knots = c(0.11)),data = pc_df )
  age.grid<-seq(from=-3000*scalef, to = 4500*scalef)/10000
  splinefit <- data.frame(age.grid,predict(fit,newdata = list(PC2=age.grid)))
  colnames(splinefit) <- c("PC2", "PC1")
  
  # plot the pcs with the spline fit
  p <- ggplot(pc_df, aes(x=PC2, y=PC1, color=DiseaseState)) +
    geom_point(size=2) + scale_color_manual(values=c("#D51F26", "#89288F", "#208A42")) + 
    xlab(paste0("PC2 (",100*summary(pcs)$importance["Proportion of Variance","PC2"], "%)")) + ylab(paste0("PC1 (",100*summary(pcs)$importance["Proportion of Variance","PC1"], "%)")) + theme_ArchR()
  p <- p+ geom_line(data=splinefit, colour="#CC0000") 
  ggsave(plot=p,height=5,width=5, filename=paste0("All_Polyp_", typeA, "_vs_", background, "_", typeA, "_pca_on_diff_genes.pdf"), useDingbats=FALSE)
  
  #get the nearest spline point for each sample
  x_vals <- c()
  for (i in 1:length(pc_df[,1])){
    x_vals <- c(x_vals,splinefit$PC2[which.min(sqrt((pc_df$PC2[i]-splinefit$PC2)**2+(pc_df$PC1[i]-splinefit$PC1)**2))])
  }
  pc_df$nearest_spline_x_vals <- x_vals
  pc_df <- pc_df[order(pc_df$nearest_spline_x_vals),]
  
  # save the results
  saveRDS(pc_df, paste0("pc_df_", background, "_background_", typeA, "_cellType.rds"))
}
```

# End of analysis